in the create event of the player or enemy object, first call set_base_stats() and add in desired base stats.
this step is optional, but recommended for finer control of movement.

create a variable eg: mstrat and set it = to new TopDownStrat();
optionally specify true or false if you want movement to be complex and include accelleration. default true.

add some colliders using mstrat.add_collider();
the specified objects can be input as a single object or an array of objects.
collider type must be a string including: "collide", "bounce", "slide", or "stick".

in the step event, create a variable that stores the total value of the x input normalized to 1, 0, or -1
do the same for the y input variable.

then simply call mstrat.move(x_input, y_input);

additional functions:

** setting base stats **
accel_set(int); change default acceleration after creation.
accel_set_temp(int); change current acceleration after creation.
accel_reset(); reset accel to base acceleration from using accel_set_temp.

frict_set(int); change default friction after creation.
frict_set_temp(int); change current friction after creation.
frict_reset(); reset frict to base friction from using frict_set_temp.

max_spd_set(int); change default max speed after creation.
max_spd_set_temp(int); change current max speed after creation.
max_spd_reset(); reset max speed to base max speed from  using max_spd_set_temp.

** setting combat stats **
hp_set(int); change the hp value after creation. mostly for applying damage and healing. 5 will heal 5 and -5 will damage 5.
hp_set_max(int); change max hp after creation.
set_damage(int); change damage after creation.

** enable or disable input **
set_input_true(); enable movement inputs.
set_input_false(); disable movement inputs.

** add, modify, and delete colliders **
add_collider(collider, "type"); add a new collider to the array.
delete_collider(collider); delete the specified collider object from the array. can also be an array of objects.
modify_collider(collider, "type"); set the collider to a new collider type, follows the same rules as add_collider.

** set and manage timers **
timer_set(duration, name, function()); creates a timer that will run the function in the second argument after the duration in milliseconds. 1,000 is one second.

example code:
set_timer(300, "input_true", function() {
	set_input_true();
});

this will set input to true after a delay of 300ms.

timer_get(name); this will check through the array of timers and return the struct whose name matches with the input.
timer_execute_early(name); this will check through the array of timers and execute and delete the timer whose name matches with the input.
timer_exists(name); this will check through the timer array and return true if a matching timer exists, else it will return false.

check_timers(); if mstrat.move() is being called, then this function is being called by default, but it can be called separately if needed.


** default movement scripts **
move(); input an x and y dir and you're off to the races. handles all collision and collision types under the hood.

dash(); briefly disables input and dashes the player at 2x specified xdir and ydir.

** common event listeners, made to be used with a state machine **
is_moving(); will return true if the player is moving, and false otherwise.
is_colliding(); will return true if the player is_colliding with a collider, and false otherwise.
is_bouncing(); will return true if the player is bouncing off a collider, and false otherwise.
is_sliding(); will return true if the player is sliding on a collider, and false otherwise.
is_sticking(); will return true if the player is sticking to a collider, and false otherwise.
is_attacking(); will return true if the player is attacking, and false otherwise.
is_hurting(); will return true if the player is being hurt, and false otherwise.
is_dashing(); will return true if the player is dashing, and false otherwise.
is_idle(); will return true if the player is idle, and false otherwise.